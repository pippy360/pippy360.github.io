<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <script src="math.js" type="text/javascript"></script>
      <script src="http://d3js.org/d3.v3.min.js"></script>
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
    <style>
        #bigBlueOuter{

            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .move { cursor: move; }
        #lineSvgTag {
            pointer-events:none;
        }
    </style>
  </head>
  <body>
    <div class="container">
        <div>
            <h1>Demo</h1>
            <p>
                <button id="transposeButton" class="btn btn-default active" onclick="changeCurrnetOperation(TransformationOperation.TRANSPOSE)" >Move</button>
                <button class="btn btn-default" onclick="changeCurrnetOperation(TransformationOperation.SCALE)" >Scale</button>
                <button class="btn btn-default" onclick="changeCurrnetOperation(TransformationOperation.ROTATE)" >Rotate</button>
                <button class="btn btn-default" onclick="changeCurrnetOperation(TransformationOperation.CROP)" >Crop</button>
                <button class="btn btn-default" onclick="toggleDrawTrianglesMode()" >Toggle DrawTriangles</button>
            </p>
            <p>
                Click and drag on the first image to apply a transformation.
            </p>
        </div>
        <div id="bigBlueOuter" >
            <canvas id="canvas" width="512" height="512"></canvas>
            <canvas id="canvas2" width="512" height="512"></canvas>
        </div>
        <div id="output">
            <span id="number_of_triangles_output"></span>
        </div>
    </div>
    <svg id="lineSvgTag" style="display: inline;position: absolute; min-height: 4px;min-width: 4px;" >
        <line id="line" x1="0" y1="0" x2="0" y2="0" style="stroke:rgb(255,0,0);stroke-width:2" />
    </svg>
    <!-- jQuery first, then Tether, then Bootstrap JS. -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha384-A7FZj7v+d/sdmMqp/nOQwliLvUsJfDHW+k9Omg/a/EheAdgtzNs3hpfag6Ed950n" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script>
  </body>
<script>

var isDown = true;
var mouseDownPoint =
{
    x: 0,
    y: 0
};

var mouseDownCanvasPoint =
{
    x: 0,
    y: 0
};


var mouseCurrentPoint =
{
    x: 0,
    y: 0
};

var mouseCurrentCanvasPoint =
{
    x: 0,
    y: 0
};




var TransformationOperation = {
    TRANSPOSE: 1,
    SCALE: 2,
    ROTATE: 3,
    CROP: 4
};

//SOURCE: GLOBALS g_global
var g_currentTranformationOperationState = TransformationOperation.TRANSPOSE;
var g_showRedTriangles = false;//show the invalid triangles (red) on the original image
var g_numberOfKeypointsToGenerate = 20;
var g_maxPntDist = 300;
var g_minPntDist = 150;
var g_minTriArea = 100;//11000;
var g_maxTriArea = 21000;
var g_shouldDrawTriangles = true;
var g_scale = 1;
var g_scaleDirection = 0;
var g_savedRotation = 0;
var g_rotation = 0;
var g_genKeypoints = [];
var g_coords = [];
var g_coords_transformation_mat = getIdentityMatrix();

var g_savedTranspose = {
    x: 0,
    y: 0
};
var g_currentTranspose = {
    x: 0,
    y: 0
};
var g_transpose = {
    x: 0,
    y: 0
}

function toggleDrawTrianglesMode() {
    g_shouldDrawTriangles = !g_shouldDrawTriangles;
    console.log("g_shouldDrawTriangles: " + g_shouldDrawTriangles);
}

function computeDistance(e){
    var y = (e.pageY-mouseDownPoint.y);
    var x = (e.pageX-mouseDownPoint.x);
//    console.log("y: " + y + " x: " + x)
    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
}

function changeCurrnetOperation(newState) {
    g_currentTranformationOperationState = newState;
    if (g_currentTranformationOperationState == TransformationOperation.TRANSPOSE) {
        $( "#canvas" ).addClass( "move" );
    } else {
        $( "#canvas" ).removeClass( "move" );
    }
}

$("#bigBlueOuter").mousedown(function(e){

    var y = (e.pageY - mouseDownPoint.y);
    mouseCurrentPoint.y = e.pageY;
    var x = (e.pageX - mouseDownPoint.x);
    mouseCurrentPoint.x = e.pageX;

    isDown = true;
    e.preventDefault();
    mouseDownPoint.x = e.pageX;
    mouseDownPoint.y = e.pageY;
    mouseDownCanvasPoint = getCanvasPoint(e);

    if (g_currentTranformationOperationState == TransformationOperation.CROP) {
      g_coords_transformation_mat = getTransformationMatrix(g_scale, g_rotation, g_transpose, g_scaleDirection, {x: 0, y: 0}, {x: 512, y: 512});
      g_coords_transformation_mat = math.inv(g_coords_transformation_mat);
      g_coords = [];
    }

});

$(document).mousemove(function(e){
    mouseCurrentCanvasPoint = getCanvasPoint(event);
    if (isDown && computeDistance(e) > 20 ) {
        var y = (e.pageY - mouseDownPoint.y);
        mouseCurrentPoint.y = e.pageY;
        var x = (e.pageX - mouseDownPoint.x);
        mouseCurrentPoint.x = e.pageX;

      if (g_currentTranformationOperationState == TransformationOperation.ROTATE) {
          //        ctx.restore();

          var extraRotation = Math.atan2(y, x) * (180.0 / Math.PI) * -1;
          if (extraRotation < 0) {
              extraRotation = (360 + (extraRotation));
          }
          g_rotation = (g_savedRotation + extraRotation) % 360;
      }else if(g_currentTranformationOperationState == TransformationOperation.SCALE){
            var div = 100;
          var direction = Math.atan2(y, x) * (180.0 / Math.PI) * -1;
          if (direction < 0) {
              direction = (360 + (direction));
          }
          g_scaleDirection = direction;

          g_scale = Math.sqrt(Math.pow(y, 2) + Math.pow(x, 2));
          g_scale /= div;
          if (g_scale < 1){
              g_scale = 1
          }
          console.log("g_scale: " + extraRotation);

      }else if(g_currentTranformationOperationState == TransformationOperation.TRANSPOSE) {

          g_currentTranspose = {
              x: x,
              y: y
          };
      }else if(g_currentTranformationOperationState == TransformationOperation.CROP) {
          g_coords.push([mouseCurrentCanvasPoint.x, mouseCurrentCanvasPoint.y]);
      }
    }
});

$(document).mouseup(function(e) {
    if(isDown) {
        isDown = false;

        $("#lineSvgTag").css("display", "none");

        if(g_currentTranformationOperationState == TransformationOperation.ROTATE){
            g_savedRotation = g_rotation;
        }else if(g_currentTranformationOperationState == TransformationOperation.TRANSPOSE) {
            g_savedTranspose = {
                x: g_savedTranspose.x + g_currentTranspose.x,
                y: g_savedTranspose.y + g_currentTranspose.y
            };
            g_currentTranspose = {
                x: 0,
                y: 0
            };
        }else if(g_currentTranformationOperationState == TransformationOperation.CROP) {

        }
    }
});
isDown = false;

function setDefaultParameters() {
    g_currentTranformationOperationState = TransformationOperation.TRANSPOSE;
    g_savedTranspose= {x: 512/2, y: 512/2};
    g_genKeypoints = generateRandomKeypoints({x: 512, y: 512}, g_numberOfKeypointsToGenerate);
    changeCurrnetOperation(TransformationOperation.TRANSPOSE);
}

window.onload = function() {
    setDefaultParameters();
};


function drawClosingPolygon(ctx, inPoints) {
    if (inPoints.length == 0) {
        return;
    }
  
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
    ctx.beginPath();

    ctx.moveTo(inPoints[0][0], inPoints[0][1]);
    for (var i = 1; i < inPoints.length; i++) {//i = 1 to skip first point
        var currentPoint = inPoints[i];
        ctx.lineTo(currentPoint[0], currentPoint[1]);
    }

    ctx.closePath();
    ctx.stroke();
};


function dragStart() {
    g_coords = [];
};

function dragMove() {
    g_coords.push([]);
};

dragEnd = function() {

};

// from https://github.com/substack/point-in-polygon
function isPointInPolygon(point, vs) {
    // ray-casting algorithm based on
    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html

    var x = point[0], y = point[1];

    var inside = false;
    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        var xi = vs[i][0], yi = vs[i][1];
        var xj = vs[j][0], yj = vs[j][1];

        var intersect = ((yi > y) != (yj > y))
            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }

    return inside;
};


function getDistance(point1, point2) {
    var a = point1.x - point2.x;
    var b = point1.y - point2.y;

    return Math.sqrt( a*a + b*b );
}

function getCanvasPoint(e)
{
  var tempCanvasPoint =
      {
          x: 0,
          y: 0
      };
  if(e.offsetX) {
      tempCanvasPoint.x = e.offsetX;
      tempCanvasPoint.y = e.offsetY;
  }
  else if(e.layerX) {
      tempCanvasPoint.x = e.layerX;
      tempCanvasPoint.y = e.layerY;
  }

  return tempCanvasPoint;
}

var sun = new Image();
var moon = new Image();
var earth = new Image();
function init() {
    sun.src = 'dog1_resize.jpg';
    window.requestAnimationFrame(draw);
}

function multiply(a, b) {
    var aNumRows = a.length, aNumCols = a[0].length,
        bNumRows = b.length, bNumCols = b[0].length,
        m = new Array(aNumRows);  // initialize array of rows
    for (var r = 0; r < aNumRows; ++r) {
        m[r] = new Array(bNumCols); // initialize the current row
        for (var c = 0; c < bNumCols; ++c) {
            m[r][c] = 0;             // initialize the current cell
            for (var i = 0; i < aNumCols; ++i) {
//                console.log(a[r][i] + " * " + b[i][c]  + " = " + a[r][i] * b[i][c]);
                m[r][c] += a[r][i] * b[i][c];
            }
        }
    }
    return m;
}


function convertToNewKeypoint(keypoint) {
    return [[keypoint.x], [keypoint.y], [1]];
}

function convertKeypointsToArrays(keypoints) {
    var ret = [];
    for (var i = 0; i < keypoints.length; i++){
        var newKeypoint = convertToNewKeypoint(keypoints[i]);
        ret.push(newKeypoint);
    }
    return ret;
}

function getScaleMatrix(scaleX, scaleY) {
    return [[scaleX, 0, 0], [0, scaleY, 0], [0, 0, 1]];
}

function getRotatoinMatrix(inRotation) {
    var toRads =  inRotation * Math.PI/180.0;
    return [
        [Math.cos(toRads), -Math.sin(toRads), 0],
        [Math.sin(toRads), Math.cos(toRads), 0],
        [0, 0, 1]
    ];
}

function getTransposeMatrix(x, y) {
    return [
        [1,0,x],
        [0,1,y],
        [0,0,1]
    ];
}

function getIdentityMatrix() {
    return [
        [1,0,0],
        [0,1,0],
        [0,0,1]
    ];
}

function getTransformationMatrix(inScale, inRotation, inTranspose, inScaleDirection, centerPointOfRotation, imageSize) {
    var centerKeypointsAroundImageCenterMat  = getTransposeMatrix(-imageSize.x/2, -imageSize.y/2);
    var transposeMat1  = getTransposeMatrix(-centerPointOfRotation.x, -centerPointOfRotation.y);
    var scaleMat = getScaleMatrix(Math.sqrt(inScale), 1.0/Math.sqrt(inScale));
    var rotationMat = getRotatoinMatrix(-1*inRotation);
    var transposeMat2  = getTransposeMatrix(centerPointOfRotation.x, centerPointOfRotation.y);
    var imageTranspose = getTransposeMatrix(inTranspose.x, inTranspose.y);
    var res = getIdentityMatrix();
    var scaleRotationMat1 = getRotatoinMatrix(inScaleDirection);
    var scaleRotationMat2 = getRotatoinMatrix(-1*inScaleDirection);

    res = multiply(centerKeypointsAroundImageCenterMat, res);
    res = multiply(transposeMat1, res);
    res = multiply(scaleRotationMat1, res);

    res = multiply(scaleMat, res);
    res = multiply(scaleRotationMat2, res);
    res = multiply(transposeMat2, res);

    res = multiply(rotationMat, res);
    res = multiply(imageTranspose, res);
    return res;
}

function applyTransformationMatToSingleKeypoint(inKeypoint, transformationMat) {
    return multiply(transformationMat, inKeypoint);
}

function applyTransformationMatToAllKeypoints(inKeypoints, transformationMat) {
    var ret = [];
    for (var i = 0; i < inKeypoints.length; i++)
    {
        var transformedKeypoint = applyTransformationMatToSingleKeypoint(inKeypoints[i], transformationMat);
        ret.push(transformedKeypoint);
    }
    return ret;
}

function convertArrayToKeypointObjects(finalArrayKeypoints) {
    var ret = [];
    for (var i = 0; i < finalArrayKeypoints.length; i++)
    {
        var arrayKeypoint = finalArrayKeypoints[i];
        var tempKeypoint = {
            x: arrayKeypoint[0][0],
            y: arrayKeypoint[1][0]
        };
        ret.push(tempKeypoint)
    }
    return ret;
}

function getNewKeypoints(keypoints, inScale, inRotation, inScaleDirection, inTranspose, centerPointOfRotation, imageSize) {

    //turn the keypoints into arrays with the extra 1 at the end!!!
    var newKeypoints = convertKeypointsToArrays(keypoints);

    //now calc the transformation mat
    var transformationMat = getTransformationMatrix(inScale, inRotation, inTranspose, inScaleDirection, centerPointOfRotation, imageSize);

    //then mult each keypoint
    var finalArrayKeypoints = applyTransformationMatToAllKeypoints(newKeypoints, transformationMat);

    //convert back to keypoint objects
    var finalKeypoints = convertArrayToKeypointObjects(finalArrayKeypoints);

    return finalKeypoints;
}

function getArea(tri){
    var a = tri[0];
    var b = tri[1];
    var c = tri[2];
    var one = (a.x-c.x)*(b.y-a.y);
    var two = (a.x-b.x)*(c.y-a.y);
    var area = Math.abs(one-two)*0.5;
    return area;
};

function checkIfPointsAreClose(tempTri) {
    var pt1 = tempTri[0];
    var pt2 = tempTri[1];
    var pt3 = tempTri[2];

    return getDistance(pt1, pt2) < g_maxPntDist
        && getDistance(pt1, pt3) < g_maxPntDist
        && getDistance(pt1, pt2) > g_minPntDist
        && getDistance(pt1, pt3) > g_minPntDist;
}

function isValidTriangle(tempTri) {
    return getArea(tempTri) > g_minTriArea && getArea(tempTri) < g_maxTriArea && checkIfPointsAreClose(tempTri);
}

function filterValidPoints(headPoint, tailcombs) {
    var ret = [];

    for (var i = 0; i < tailcombs.length; i++) {
        var currPt = tailcombs[i];
        if (getDistance(currPt, headPoint) < g_maxPntDist && getDistance(currPt, headPoint) > g_minPntDist){
            ret.push([currPt]);
        }
    }
    return ret;
}

function filtered_k_combinations(inKeypoints) {
    var ret = [];
    for (var i = 0; i < inKeypoints.length - 2; i++) {
        var keypoint = inKeypoints[i];
        var tail = inKeypoints.slice(i + 1);
        var subsetOfValidPoints = filterValidPoints(keypoint, tail);
        var combs = k_combinations(subsetOfValidPoints, 2);
        for (var j = 0; j < combs.length; j++) {
            var currComb = combs[j];
            var tempTriangle = [keypoint, currComb[0][0], currComb[1][0]];
            ret.push(tempTriangle);
        }
    }
    return ret;
}

function k_combinations(set, k) {
    var i, j, combs, head, tailcombs;

    // There is no way to take e.g. sets of 5 elements from
    // a set of 4.
    if (k > set.length || k <= 0) {
        return [];
    }

    // K-sized set has only one K-sized subset.
    if (k == set.length) {
        return [set];
    }

    // There is N 1-sized subsets in a N-sized set.
    if (k == 1) {
        combs = [];
        for (i = 0; i < set.length; i++) {
            combs.push([set[i]]);
        }
        return combs;
    }

    // Assert {1 < k < set.length}

    // Algorithm description:
    // To get k-combinations of a set, we want to join each element
    // with all (k-1)-combinations of the other elements. The set of
    // these k-sized sets would be the desired result. However, as we
    // represent sets with lists, we need to take duplicates into
    // account. To avoid producing duplicates and also unnecessary
    // computing, we use the following approach: each element i
    // divides the list into three: the preceding elements, the
    // current element i, and the subsequent elements. For the first
    // element, the list of preceding elements is empty. For element i,
    // we compute the (k-1)-computations of the subsequent elements,
    // join each with the element i, and store the joined to the set of
    // computed k-combinations. We do not need to take the preceding
    // elements into account, because they have already been the i:th
    // element so they are already computed and stored. When the length
    // of the subsequent list drops below (k-1), we cannot find any
    // (k-1)-combs, hence the upper limit for the iteration:
    combs = [];
    for (i = 0; i < set.length - k + 1; i++) {
        // head is a list that includes only our current element.
        head = set.slice(i, i + 1);
        // We take smaller combinations from the subsequent elements
        tailcombs = k_combinations(set.slice(i + 1), k - 1);
        // For each (k-1)-combination we join it with the current
        // and store it to the set of k-combinations.
        for (j = 0; j < tailcombs.length; j++) {
            combs.push(head.concat(tailcombs[j]));
        }
    }
    return combs;
}
function getTheTriangles(newKeypoints) {
    return filtered_k_combinations(newKeypoints);
}

function drawTriangleWithColour(ctx, tri, colour) {
    ctx.strokeStyle = 'rgba('+ colour[0] +', '+ colour[1] +' ,'+ colour[2] +', .9)';
    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
    ctx.beginPath();
    ctx.moveTo(tri[0].x, tri[0].y);
    ctx.lineTo(tri[1].x, tri[1].y);
    ctx.lineTo(tri[2].x, tri[2].y);
    ctx.closePath();
    ctx.stroke();
}

function drawTriangle(ctx, tri) {
    drawTriangleWithColour(ctx, tri, [0, 153, 255])
}

function filterBasedOnVisible(keypoints, boundingBox) {
    var ret = [];
    for (var i = 0; i < keypoints.length; i++) {
        var keypoint = keypoints[i];
        if( keypoint.x >= boundingBox.x
            || keypoint.x < 0
            || keypoint.y >= boundingBox.y
            || keypoint.y < 0)
        {
            //ignore this keypoint
        } else {
            ret.push(keypoint)
        }
    }
    return ret;
}


function applyTransformationMatToTriangle(tri, convertToOriginalImageMat) {
    var ret = [];
    for (var i = 0; i < tri.length; i++) {
        var kp = tri[i];
        kp = convertToNewKeypoint(kp);
        var newKp = applyTransformationMatToSingleKeypoint(kp, convertToOriginalImageMat);
        var newKp = {
            x: newKp[0][0],
            y: newKp[1][0]
        };
        ret.push(newKp);
    }
    return ret;
}
function isValidTriangle_DrawingTest(newTri) {
    return getDistance(newTri[0], newTri[1]) < g_maxPntDist
        && getDistance(newTri[0], newTri[1]) < g_maxPntDist
        && getDistance(newTri[0], newTri[2]) > g_minPntDist
        && getDistance(newTri[0], newTri[2]) > g_minPntDist
        ;
}

function drawTriangleWithTransformationMatrix(ctx2, tri, convertToOriginalImageMat) {

    var newTri = applyTransformationMatToTriangle(tri, convertToOriginalImageMat);
    if(isValidTriangle_DrawingTest(newTri)){
        drawTriangle(ctx2, newTri);
    } else {
        if(g_showRedTriangles){
            drawTriangleWithColour(ctx2, newTri, [255,0,0]);
        }
    }
}


function generateRandomKeypoints(imageSize, numberOfKeypoints) {

    var ret = [];
    for (var i = 0; i < numberOfKeypoints; i++) {

        var x = Math.floor((Math.random() * imageSize.x));
        var y = Math.floor((Math.random() * imageSize.y));
        var kp = {
            x: x,
            y: y
        };
        ret.push(kp)
    }
    return ret;
}

function drawLine(inMouseDownPoint, inMouseCurrentPoint) {

    if (g_currentTranformationOperationState == TransformationOperation.ROTATE
        || g_currentTranformationOperationState == TransformationOperation.SCALE) {
        //continue
    }else{
        return;
    }

    $("#lineSvgTag").css("display", "inline");

    var startx = Math.min(inMouseDownPoint.x, inMouseCurrentPoint.x);
    var starty = Math.min(inMouseDownPoint.y, inMouseCurrentPoint.y);
    var endx = Math.max(inMouseDownPoint.x, inMouseCurrentPoint.x);
    var endy = Math.max(inMouseDownPoint.y, inMouseCurrentPoint.y);

    $( "#lineSvgTag" ).css('left', startx + 'px');
    $( "#lineSvgTag" ).css('top', starty + 'px');

    var x1 = inMouseDownPoint.x - startx;
    var y1 = inMouseDownPoint.y - starty;
    $( "#line" ).attr('x1', x1);
    $( "#line" ).attr('y1', y1);

    var x2 = inMouseCurrentPoint.x - inMouseDownPoint.x;
    var y2 = inMouseCurrentPoint.y - inMouseDownPoint.y;
    $( "#line" ).attr('x2', x2 + x1);
    $( "#line" ).attr('y2', y2 + y1);

    $( "#lineSvgTag" ).css('width', endx - startx);
    $( "#lineSvgTag" ).css('height', endy - starty);

}


function filterBasedOnClosingPoly(keypoints, coords) {
    if(coords.length == 0){
        return keypoints;
    }

    var ret = [];
    for (var i = 0; i < keypoints.length; i++) {
        var keypoint = keypoints[i];
        if(isPointInPolygon([keypoint.x, keypoint.y], coords)){
            ret.push(keypoint);
        }
    }
    return ret;
}
  
function applyTransformationToEveryPolyPoint(coords, transformationMat) {
    var ret = [];
    for (var i = 0; i < coords.length; i++) {
        var tempKeypoint = applyTransformationMatToSingleKeypoint([[coords[i][0]],[coords[i][1]], [1]], transformationMat);
        ret.push([tempKeypoint[0][0], tempKeypoint[1][0]]);
    }
    return ret;
}

function getTransformedPolyPoints(coords, inScale, inRotation, inScaleDirection, inTranspose, centerPointOfRotation, imageSize) {
    if(coords.length == 0){
        return [];
    }
  
    var transformationMat = getTransformationMatrix(inScale, inRotation, inTranspose, inScaleDirection, centerPointOfRotation, imageSize);
    var tempCoords = applyTransformationToEveryPolyPoint(coords, g_coords_transformation_mat);
    return applyTransformationToEveryPolyPoint(tempCoords, transformationMat);
}

function draw() {

    g_transpose = {
        x: (g_savedTranspose.x + g_currentTranspose.x),
        y: (g_savedTranspose.y + g_currentTranspose.y)
    };

    var ctx = document.getElementById('canvas').getContext('2d');
    var ctx2 = document.getElementById('canvas2').getContext('2d');
    ctx2.drawImage(sun, 0, 0);
    ctx.globalCompositeOperation = 'destination-over';
    ctx.clearRect(0, 0, 512, 512); // clear canvas

    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
    ctx.strokeStyle = 'rgba(0, 153, 255, 0.4)';

    var time = new Date();

    ctx.save();

    if (isDown) {
        drawLine(mouseDownPoint, mouseCurrentPoint);
    }

    ctx.restore();

    //now draw the keypoints
    var newKeypoints = getNewKeypoints(g_genKeypoints, g_scale, g_rotation, g_scaleDirection, g_transpose, {x: 0, y: 0}, {x: 512, y: 512});

    var transformedPolyPoints = getTransformedPolyPoints(g_coords, g_scale, g_rotation, g_scaleDirection, g_transpose, {x: 0, y: 0}, {x: 512, y: 512});
    drawClosingPolygon(ctx, transformedPolyPoints);

    if(g_shouldDrawTriangles){
        var tempFilteredKeypointsStep = filterBasedOnVisible(newKeypoints, {x: 512, y: 512});//input is canvas/imageCutout size
        var filteredKeypoints = filterBasedOnClosingPoly(tempFilteredKeypointsStep, transformedPolyPoints);//input is canvas/imageCutout size

        var triangles = getTheTriangles(filteredKeypoints);
        $("#number_of_triangles_output").html("Number of triangles: " + triangles.length);
        for (var i = 0; i < triangles.length; i++) {
            var tri = triangles[i];
            var transMat = getTransformationMatrix(g_scale, g_rotation, g_transpose, g_scaleDirection, {x: 0, y: 0}, {x: 512, y: 512});
            var convertToOriginalImageMat = math.inv(transMat);
            drawTriangleWithTransformationMatrix(ctx2, tri, convertToOriginalImageMat);
            drawTriangle(ctx, tri);
            //do the translation map
            //draw the next triangle
        }

        for (var i = 0; i < filteredKeypoints.length; i++)
        {
            var kp = filteredKeypoints[i];
//            ctx.fillStyle = 'rgba(255, 0, 0, 1.0)';
//            ctx.fillRect(kp.x+2,kp.y+2,4,4);
//            ctx.fillStyle = 'rgba(0, 0, 255, 0.5)';
//            ctx.fillRect(kp.x,kp.y,4,4);
        }
    }

    ctx.save();

    ctx.translate(g_transpose.x, g_transpose.y);
    ctx.rotate(g_rotation * Math.PI/180.0 * -1.0);
    ctx.rotate(g_scaleDirection * Math.PI/180.0 * -1.0);
    ctx.scale(Math.sqrt(g_scale), 1.0/Math.sqrt(g_scale));
    ctx.rotate(g_scaleDirection * Math.PI/180.0);
//    ctx.translate(sun.width/2, sun.width/2);
    ctx.drawImage(sun, -sun.width/2, -sun.height/2);


    for (var i = 0; i < g_genKeypoints.length; i++)
    {
        var kp = g_genKeypoints[i];
//        ctx2.fillStyle = 'rgba(255, 0, 0, 1.0)';
//        ctx2.fillRect(kp.x+2,kp.y+2,4,4);
//        ctx2.fillStyle = 'rgba(0, 0, 255, 0.5)';
//        ctx2.fillRect(kp.x,kp.y,4,4);
    }


    ctx.restore();

    window.requestAnimationFrame(draw);
}

init();

</script>
</html>
