<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
    <style>
        #bigBlueOuter{

            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Hello, world!</h1>
        <div id="bigBlueOuter" >
          <canvas id="canvas" width="512" height="512">
          </canvas>
          <canvas id="bigBlueInner" width="512" height="512">
          </canvas>
          <div id="output"></div>
        </div>
    </div>
    <!-- jQuery first, then Tether, then Bootstrap JS. -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha384-A7FZj7v+d/sdmMqp/nOQwliLvUsJfDHW+k9Omg/a/EheAdgtzNs3hpfag6Ed950n" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script>
  </body>
<script>

var isDown = true;
var mouseDownPoint =
{
    x: 0,
    y: 0
};

var mouseDownCanvasPoint =
{
    x: 0,
    y: 0
};


var mouseCurrentPoint =
{
    x: 0,
    y: 0
};

var mouseCurrentCanvasPoint =
{
    x: 0,
    y: 0
};


$("#bigBlueOuter").mousedown(function(e){
    isDown = true;
    e.preventDefault();
    mouseDownPoint.x = e.pageX;
    mouseDownPoint.y = e.pageY;
    mouseDownCanvasPoint = getCanvasPoint(e);
});


var g_scale = 1;
var savedRotation = 0;
var g_rotation = 0;

function computeDistance(e){
    var y = (e.pageY-mouseDownPoint.y);
    var x = (e.pageX-mouseDownPoint.x);
    console.log("y: " + y + " x: " + x)
    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
}

$(document).mousemove(function(e){
    if(isDown && computeDistance(e) > 20 ){
//        ctx.restore();
        var div = 100;
        var y = (e.pageY-mouseDownPoint.y);
        mouseCurrentPoint.y = e.pageY;
        var x = (e.pageX-mouseDownPoint.x);
        mouseCurrentPoint.x = e.pageX;
        g_scale = Math.sqrt( Math.pow(y, 2) + Math.pow(x, 2));
        g_scale /= div;
        if (g_scale < 1)
            g_scale = 1
        extraRotation = Math.atan2(y, x) * (180.0/Math.PI) * -1;
        if (extraRotation < 0){
            extraRotation = (360 + (extraRotation));
        }
        g_rotation = (savedRotation + extraRotation)%360;
    }
});


var keypoints = [
    { x: 100, y: 100},
    { x: 200, y: 100},
    { x: 200, y: 200},
    { x: 100, y: 200},
    { x: 256, y: 256}
];


$(document).mouseup(function(e) {
    if(isDown) {
      isDown = false;
      savedRotation = g_rotation;
    }
});
isDown = false;


var sun = new Image();

window.onload = function() {
//    var img=document.getElementById("lenna");
//    var c=document.getElementById("bigBlueInner");
//    var ctx=c.getContext("2d");
//    ctx.save();
//    ctx.rotate(0.5);
//    ctx.drawImage(img,0,0);
};

function getCanvasPoint(e)
{
  var tempCanvasPoint =
      {
          x: 0,
          y: 0
      };
  if(e.offsetX) {
      tempCanvasPoint.x = e.offsetX;
      tempCanvasPoint.y = e.offsetY;
  }
  else if(e.layerX) {
      tempCanvasPoint.x = e.layerX;
      tempCanvasPoint.y = e.layerY;
  }

  return tempCanvasPoint;
}


$( document ).mousemove(function( event ) {
  mouseCurrentCanvasPoint = getCanvasPoint(event)
});

var sun = new Image();
var moon = new Image();
var earth = new Image();
function init() {
    sun.src = 'lennaWithGreenDots.jpg';
    window.requestAnimationFrame(draw);
}

function multiply(a, b) {
    var aNumRows = a.length, aNumCols = a[0].length,
        bNumRows = b.length, bNumCols = b[0].length,
        m = new Array(aNumRows);  // initialize array of rows
    for (var r = 0; r < aNumRows; ++r) {
        m[r] = new Array(bNumCols); // initialize the current row
        for (var c = 0; c < bNumCols; ++c) {
            m[r][c] = 0;             // initialize the current cell
            for (var i = 0; i < aNumCols; ++i) {
                console.log(a[r][i] + " * " + b[i][c]  + " = " + a[r][i] * b[i][c]);
                m[r][c] += a[r][i] * b[i][c];
            }
        }
    }
    return m;
}


function convertToNewKeypoint(keypoint) {
    return [[keypoint.x], [keypoint.y], [1]];
}

function convertKeypointsToArrays(keypoints) {
    var ret = []
    for (var i = 0; i < keypoints.length; i++){
        var newKeypoint = convertToNewKeypoint(keypoints[i]);
        ret.push(newKeypoint);
    }
    return ret;
}

function getScaleMatrix(scaleX, scaleY) {
    return [[scaleX, 0, 0], [0, scaleY, 0], [0, 0, 1]];
}

function getRotatoinMatrix(inRotation) {
    var toRads =  inRotation * Math.PI/180.0
    return [
        [Math.cos(toRads), -Math.sin(toRads), 0],
        [Math.sin(toRads), Math.cos(toRads), 0],
        [0, 0, 1]
    ];
}

function getTransposeMatrix(x, y) {
    return [
        [1,0,x],
        [0,1,y],
        [0,0,1]
    ];
}

function getIdentityMatrix() {
    return [
        [1,0,0],
        [0,1,0],
        [0,0,1]
    ];
}

function getTransformationMatrix(inScale, inRotation, centerPoint) {
    var transposeMat1  = getTransposeMatrix(-centerPoint.x, -centerPoint.y);
    var scaleMat = getScaleMatrix(Math.sqrt(inScale), 1.0/Math.sqrt(inScale));
    var rotationMat = getRotatoinMatrix(-1*inRotation);
    var transposeMat2  = getTransposeMatrix(centerPoint.x, centerPoint.y);
    var res = getIdentityMatrix();
    res = multiply(transposeMat1, res);
    res = multiply(rotationMat, res);
    res = multiply(scaleMat, res);
    res = multiply(transposeMat2, res);
    return res;
}

function applyTransformationMatToSingleKeypoint(inKeypoint, transformationMat) {
    return multiply(transformationMat, inKeypoint);
}

function applyTransformationMatToAllKeypoints(inKeypoints, transformationMat) {
    var ret = [];
    for (var i = 0; i < inKeypoints.length; i++)
    {
        var transformedKeypoint = applyTransformationMatToSingleKeypoint(inKeypoints[i], transformationMat);
        ret.push(transformedKeypoint);
    }
    return ret;
}

function convertArrayToKeypointObjects(finalArrayKeypoints) {
    var ret = [];
    for (var i = 0; i < finalArrayKeypoints.length; i++)
    {
        var arrayKeypoint = finalArrayKeypoints[i];
        var tempKeypoint = {
            x: arrayKeypoint[0],
            y: arrayKeypoint[1]
        };
        ret.push(tempKeypoint)
    }
    return ret;
}

function getNewKeypoints(keypoints, inScale, inRotation, centerPoint) {

    //turn the keypoints into arrays with the extra 1 at the end!!!
    var newKeypoints = convertKeypointsToArrays(keypoints);

    //now calc the transformation mat
    var transformationMat = getTransformationMatrix(inScale, inRotation, centerPoint);

    //then mult each keypoint
    var finalArrayKeypoints = applyTransformationMatToAllKeypoints(newKeypoints, transformationMat);

    //convert back to keypoint objects
    var finalKeypoints = convertArrayToKeypointObjects(finalArrayKeypoints );

    return finalKeypoints;
}

function draw() {
    var ctx = document.getElementById('canvas').getContext('2d');

    ctx.globalCompositeOperation = 'destination-over';
    ctx.clearRect(0, 0, 512, 512); // clear canvas

    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
    ctx.strokeStyle = 'rgba(0, 153, 255, 0.4)';

    var time = new Date();

    ctx.save();

    if (isDown) {
        ctx.beginPath();
        ctx.moveTo(mouseDownCanvasPoint.x, mouseDownCanvasPoint.y);
        ctx.lineTo(mouseCurrentCanvasPoint.x, mouseCurrentCanvasPoint.y);
        ctx.stroke();
    }


    ctx.restore();

    //now draw the keypoints
    var newKeypoints = getNewKeypoints(keypoints, g_scale, g_rotation, {x: 512/2, y: 512/2});

    for (var i = 0; i < newKeypoints.length; i++)
    {
        var kp = newKeypoints[i];
        console.log("done");
        ctx.fillStyle = 'rgba(255, 0, 0, 1.0)';
        ctx.fillRect(kp.x+2,kp.y+2,4,4);
        ctx.fillStyle = 'rgba(0, 0, 255, 0.5)';
        ctx.fillRect(kp.x,kp.y,4,4);
    }

    ctx.save();

    ctx.translate(512/2, 512/2);
    ctx.scale(Math.sqrt(g_scale), 1.0/Math.sqrt(g_scale));
    ctx.rotate(g_rotation * Math.PI/180.0 * -1.0);
    ctx.translate(-512/2, -512/2);
    ctx.drawImage(sun, 0, 0);

    ctx.restore();

    window.requestAnimationFrame(draw);
}

init();

</script>
</html>
