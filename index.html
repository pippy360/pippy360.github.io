<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
      <script src="math.js" type="text/javascript"></script>
      <script src="http://d3js.org/d3.v3.min.js"></script>
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
    <style>
        #bigBlueOuter{

            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .move { cursor: move; }
        #lineSvgTag {
            pointer-events:none;
        }
    </style>
  </head>
  <body>
    <div class="container">
        <div>
            <h1>Demo</h1>
            <p>
                <button id="transposeButton" class="btn btn-default active" onclick="setCurrnetOperation(g_TransformationOperation.TRANSPOSE)" >Move</button>
                <button class="btn btn-default" onclick="setCurrnetOperation(g_TransformationOperation.SCALE)" >Scale</button>
                <button class="btn btn-default" onclick="setCurrnetOperation(g_TransformationOperation.ROTATE)" >Rotate</button>
                <button class="btn btn-default" onclick="setCurrnetOperation(g_TransformationOperation.CROP)" >Crop</button>
                <button class="btn btn-default" onclick="toggleDrawTrianglesMode()" >Toggle DrawTriangles</button>
                <button class="btn btn-default" style="float:right;" onclick="callSearch()" >CompareImages</button>

            </p>
            <p>
                Click and drag on the first image to apply a transformation.
            </p>
        </div>
        <div id="bigBlueOuter" >
            <canvas id="interactiveCanvas" width="512" height="512"></canvas>
            <canvas id="referenceCanvas" width="512" height="512"></canvas>
        </div>
        <div id="output">
            <span id="searchResultsOutput">
                <div id="searchResultsOutputDiv" class="alert alert-success" role="alert">
                  <strong>Matched!</strong> X matches found
                </div>
            </span>
            <span id="number_of_triangles_output"></span>
        </div>
    </div>
    <svg id="lineSvgTag" style="display: inline;position: absolute; min-height: 4px;min-width: 4px;" >
        <line id="line" x1="0" y1="0" x2="0" y2="0" style="stroke:rgb(255,0,0);stroke-width:2" />
    </svg>
    <!-- jQuery first, then Tether, then Bootstrap JS. -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script>
    <script src="main.js"></script>

  </body>
<script>

//var isDown = true;
//var mouseDownPoint =
//{
//    x: 0,
//    y: 0
//};
//
//var mouseDownCanvasPoint =
//{
//    x: 0,
//    y: 0
//};
//
//
//var mouseCurrentPoint =
//{
//    x: 0,
//    y: 0
//};
//
//var mouseCurrentCanvasPoint =
//{
//    x: 0,
//    y: 0
//};
//
//
//
//
//var g_TransformationOperation = {
//    TRANSPOSE: 1,
//    SCALE: 2,
//    ROTATE: 3,
//    CROP: 4
//};
//
////SOURCE: GLOBALS g_global
//var g_currentTranformationOperationState = g_TransformationOperation.TRANSPOSE;
//var g_showRedTriangles = false;//show the invalid triangles (red) on the original image
//var g_numberOfKeypointsToGenerate = 20;
//var g_maxPntDist = 300;
//var g_minPntDist = 150;
//var g_minTriArea = 100;//11000;
//var g_maxTriArea = 21000;
//var g_shouldDrawTriangles = true;
//var g_scale = 1;
//var g_currentScale= 1;
//var g_savedScale = 1;
//var g_scaleDirection = 0;
//var g_currentScaleDirection = 0;
//var g_savedScaleDirection = 0;
//var g_savedRotation = 0;
//var g_rotation = 0;
//var g_genKeypoints = [];
//var g_coords = [];
//var g_coords_transformation_mat = getIdentityMatrix();
//
//var g_savedTranspose = {
//    x: 0,
//    y: 0
//};
//var g_currentTranspose = {
//    x: 0,
//    y: 0
//};
//var g_transpose = {
//    x: 0,
//    y: 0
//}
//
//function toggleDrawTrianglesMode() {
//    g_shouldDrawTriangles = !g_shouldDrawTriangles;
//    console.log("g_shouldDrawTriangles: " + g_shouldDrawTriangles);
//}
//
//function computeDistance(e){
//    var y = (e.pageY-mouseDownPoint.y);
//    var x = (e.pageX-mouseDownPoint.x);
////    console.log("y: " + y + " x: " + x)
//    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
//}
//
//function setCurrnetOperation(newState) {
//    g_currentTranformationOperationState = newState;
//    if (g_currentTranformationOperationState == g_TransformationOperation.TRANSPOSE) {
//        $( "#canvas" ).addClass( "move" );
//    } else {
//        $( "#canvas" ).removeClass( "move" );
//    }
//}
//
//$("#canvas").mousedown(function(e){
//
//    var y = (e.pageY - mouseDownPoint.y);
//    mouseCurrentPoint.y = e.pageY;
//    var x = (e.pageX - mouseDownPoint.x);
//    mouseCurrentPoint.x = e.pageX;
//
//    isDown = true;
//    e.preventDefault();
//    mouseDownPoint.x = e.pageX;
//    mouseDownPoint.y = e.pageY;
//    mouseDownCanvasPoint = getCanvasPoint(e);
//
//    if (g_currentTranformationOperationState == g_TransformationOperation.CROP) {
//      g_coords_transformation_mat = getTransformationMatrix(g_scale, g_rotation, g_transpose, g_scaleDirection, {x: 0, y: 0}, {x: 512, y: 512});
//      g_coords_transformation_mat = math.inv(g_coords_transformation_mat);
//      g_coords = [];
//    }
//
//});
//
//$("#canvas").mousemove(function(e){
//    mouseCurrentCanvasPoint = getCanvasPoint(e);
//    if (isDown && computeDistance(e) > 20 ) {
//        var y = (e.pageY - mouseDownPoint.y);
//        mouseCurrentPoint.y = e.pageY;
//        var x = (e.pageX - mouseDownPoint.x);
//        mouseCurrentPoint.x = e.pageX;
//
//      if (g_currentTranformationOperationState == g_TransformationOperation.ROTATE) {
//          //        ctx.restore();
//
//          var extraRotation = Math.atan2(y, x) * (180.0 / Math.PI) * -1;
//          if (extraRotation < 0) {
//              extraRotation = (360 + (extraRotation));
//          }
//          g_rotation = (g_savedRotation + extraRotation) % 360;
//      }else if(g_currentTranformationOperationState == g_TransformationOperation.SCALE){
//            var div = 100;
//          var direction = Math.atan2(y, x) * (180.0 / Math.PI) * -1;
//          if (direction < 0) {
//              direction = (360 + (direction));
//          }
//          g_currentScaleDirection = direction;
//
//          g_currentScale = Math.sqrt(Math.pow(y, 2) + Math.pow(x, 2));
//          g_currentScale /= div;
//          if (g_currentScale < 1){
//              g_currentScale = 1
//          }
//
////          console.log("g_scale: " + extraRotation);
//
//      }else if(g_currentTranformationOperationState == g_TransformationOperation.TRANSPOSE) {
//
//          g_currentTranspose = {
//              x: x,
//              y: y
//          };
//      }else if(g_currentTranformationOperationState == g_TransformationOperation.CROP) {
//          g_coords.push([mouseCurrentCanvasPoint.x, mouseCurrentCanvasPoint.y]);
//      }
//    }
//});
//
//$(document).mouseup(function(e) {
//    if(isDown) {
//        isDown = false;
//
//        $("#lineSvgTag").css("display", "none");
//
//        if(g_currentTranformationOperationState == g_TransformationOperation.ROTATE){
//            g_savedRotation = g_rotation;
//        }else if(g_currentTranformationOperationState == g_TransformationOperation.TRANSPOSE) {
//            g_savedTranspose = {
//                x: g_savedTranspose.x + g_currentTranspose.x,
//                y: g_savedTranspose.y + g_currentTranspose.y
//            };
//            g_currentTranspose = {
//                x: 0,
//                y: 0
//            };
//        }else if(g_currentTranformationOperationState == g_TransformationOperation.CROP) {
//
//        }else if(g_currentTranformationOperationState == g_TransformationOperation.SCALE) {
//            g_savedScale = g_scale;
//            g_savedScaleDirection = g_currentScaleDirection;
//        }
//    }
//});
//isDown = false;
//
//function setDefaultParameters() {
//    g_currentTranformationOperationState = g_TransformationOperation.TRANSPOSE;
//    g_savedTranspose= {x: 512/2, y: 512/2};
//    g_genKeypoints = generateRandomKeypoints({x: 512, y: 512}, g_numberOfKeypointsToGenerate);
//    setCurrnetOperation(g_TransformationOperation.TRANSPOSE);
//}
//
//window.onload = function() {
//    setDefaultParameters();
//};
//
//
//function drawClosingPolygon(ctx, inPoints) {
//    if (inPoints.length == 0) {
//        return;
//    }
//
//    ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
//    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
//    ctx.beginPath();
//
//    ctx.moveTo(0, 0);
//    ctx.lineTo(0, 512);
//    ctx.lineTo(512, 512);
//    ctx.lineTo(512, 0);
//    ctx.closePath();
//
//    ctx.moveTo(inPoints[0][0], inPoints[0][1]);
//    for (var i = 1; i < inPoints.length; i++) {//i = 1 to skip first point
//        var currentPoint = inPoints[i];
//        ctx.lineTo(currentPoint[0], currentPoint[1]);
//    }
//    ctx.closePath();
//
//    //fill
//    ctx.fillStyle = "#f2f2f2";
//    ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
//    if(isDown && g_currentTranformationOperationState == g_TransformationOperation.CROP){
//        ctx.fillStyle = 'rgba(242, 242, 242, 0.3)';
//    }
//    ctx.mozFillRule = 'evenodd'; //for old firefox 1~30
//    ctx.fill('evenodd'); //for firefox 31+, IE 11+, chrome
//    ctx.stroke();
//};
//
//function callSearch() {
//    var canvas1 = document.getElementById('canvas');
//    var image1 = canvas1.toDataURL('image/jpeg', 0.92).replace("image/jpeg", "image/octet-stream");  // here is the most important part because if you dont replace you will get a DOM 18 exception.
//    var canvas2 = document.getElementById('canvas2');
//    var image2 = canvas2.toDataURL('image/jpeg', 0.92).replace("image/jpeg", "image/octet-stream");  // here is the most important part because if you dont replace you will get a DOM 18 exception.
//
//    var transformedPolyPoints = getTransformedPolyPoints(g_coords, g_scale, g_rotation, g_scaleDirection, g_transpose, {x: 0, y: 0}, {x: 512, y: 512});
//    var newKeypoints = getNewKeypoints(g_genKeypoints, g_scale, g_rotation, g_scaleDirection, g_transpose, {x: 0, y: 0}, {x: 512, y: 512});
//    var tempFilteredKeypointsStep = filterBasedOnVisible(newKeypoints, {x: 512, y: 512});//input is canvas/imageCutout size
//    var filteredKeypoints = filterBasedOnClosingPoly(tempFilteredKeypointsStep, transformedPolyPoints);//input is canvas/imageCutout size
//
//    var regex = /^data:.+\/(.+);base64,(.*)$/;
//
//    var matches;
//    matches = image1.match(regex);
//    var data1 = matches[2];
//    matches = image2.match(regex);
//    var data2 = matches[2];
//
//    var info = {
//        'image1': {
//            'imageData': data1,
//            'keypoints': filteredKeypoints
//        },
//        'image2': {
//            'imageData': data2,
//            'keypoints': g_genKeypoints
//        }
//    };
//
//    $("#searchResultsOutputDiv").html("loading...");
//
//    $.ajax({
//        url: 'http://104.198.245.1/runTestWithJsonData',
//        type: 'POST',
//        data: JSON.stringify(info),
//        contentType: 'application/json; charset=utf-8',
//        dataType: 'json',
//        async: true,
//        success: function(msg) {
//            console.log(msg);
//            $("#searchResultsOutputDiv").html("Found this many matches: " + msg);
//        },
//        error: function(msg) {
//
//        }
//    });
//}
//
//function dragStart() {
//    g_coords = [];
//};
//
//function dragMove() {
//    g_coords.push([]);
//};
//
//dragEnd = function() {
//
//};
//
//// from https://github.com/substack/point-in-polygon
//function isPointInPolygon(point, vs) {
//    // ray-casting algorithm based on
//    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
//
//    var x = point[0], y = point[1];
//
//    var inside = false;
//    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
//        var xi = vs[i][0], yi = vs[i][1];
//        var xj = vs[j][0], yj = vs[j][1];
//
//        var intersect = ((yi > y) != (yj > y))
//            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
//        if (intersect) inside = !inside;
//    }
//
//    return inside;
//};
//
//
//function getDistance(point1, point2) {
//    var a = point1.x - point2.x;
//    var b = point1.y - point2.y;
//
//    return Math.sqrt( a*a + b*b );
//}
//
//function getCanvasPoint(e)
//{
//  var tempCanvasPoint =
//      {
//          x: 0,
//          y: 0
//      };
//  if(e.offsetX) {
//      tempCanvasPoint.x = e.offsetX;
//      tempCanvasPoint.y = e.offsetY;
////      console.log({x: e.offsetX, y: e.offsetY});
//  }
//  else if(e.layerX) {
//      tempCanvasPoint.x = e.layerX;
//      tempCanvasPoint.y = e.layerY;
//  }
//
//  return tempCanvasPoint;
//}
//
//var sun = new Image();
//var moon = new Image();
//var earth = new Image();
//function init() {
//    sun.src = 'dog1_resize.jpg';
//    window.requestAnimationFrame(draw);
//}
//
//function multiply(a, b) {
//    var aNumRows = a.length, aNumCols = a[0].length,
//        bNumRows = b.length, bNumCols = b[0].length,
//        m = new Array(aNumRows);  // initialize array of rows
//    for (var r = 0; r < aNumRows; ++r) {
//        m[r] = new Array(bNumCols); // initialize the current row
//        for (var c = 0; c < bNumCols; ++c) {
//            m[r][c] = 0;             // initialize the current cell
//            for (var i = 0; i < aNumCols; ++i) {
////                console.log(a[r][i] + " * " + b[i][c]  + " = " + a[r][i] * b[i][c]);
//                m[r][c] += a[r][i] * b[i][c];
//            }
//        }
//    }
//    return m;
//}
//
//
//function convertToNewKeypoint(keypoint) {
//    return [[keypoint.x], [keypoint.y], [1]];
//}
//
//function convertKeypointsToArrays(keypoints) {
//    var ret = [];
//    for (var i = 0; i < keypoints.length; i++){
//        var newKeypoint = convertToNewKeypoint(keypoints[i]);
//        ret.push(newKeypoint);
//    }
//    return ret;
//}
//
//function getScaleMatrix(scaleX, scaleY) {
//    return [[scaleX, 0, 0], [0, scaleY, 0], [0, 0, 1]];
//}
//
//function getRotatoinMatrix(inRotation) {
//    var toRads =  inRotation * Math.PI/180.0;
//    return [
//        [Math.cos(toRads), -Math.sin(toRads), 0],
//        [Math.sin(toRads), Math.cos(toRads), 0],
//        [0, 0, 1]
//    ];
//}
//
//function getTransposeMatrix(x, y) {
//    return [
//        [1,0,x],
//        [0,1,y],
//        [0,0,1]
//    ];
//}
//
//function getIdentityMatrix() {
//    return [
//        [1,0,0],
//        [0,1,0],
//        [0,0,1]
//    ];
//}
//
//function getTransformationMatrix(inScale, inRotation, inTranspose, inScaleDirection, centerPointOfRotation, imageSize) {
//    var centerKeypointsAroundImageCenterMat  = getTransposeMatrix(-imageSize.x/2, -imageSize.y/2);
//    var transposeMat1  = getTransposeMatrix(-centerPointOfRotation.x, -centerPointOfRotation.y);
//    var scaleMat = getScaleMatrix(Math.sqrt(inScale), 1.0/Math.sqrt(inScale));
//    var rotationMat = getRotatoinMatrix(-1*inRotation);
//    var transposeMat2  = getTransposeMatrix(centerPointOfRotation.x, centerPointOfRotation.y);
//    var imageTranspose = getTransposeMatrix(inTranspose.x, inTranspose.y);
//    var res = getIdentityMatrix();
//    var scaleRotationMat1 = getRotatoinMatrix(inScaleDirection);
//    var scaleRotationMat2 = getRotatoinMatrix(-1*inScaleDirection);
//
//    res = multiply(centerKeypointsAroundImageCenterMat, res);
//    res = multiply(transposeMat1, res);
//    res = multiply(scaleRotationMat1, res);
//
//    res = multiply(scaleMat, res);
//    res = multiply(scaleRotationMat2, res);
//    res = multiply(transposeMat2, res);
//
//    res = multiply(rotationMat, res);
//    res = multiply(imageTranspose, res);
//    return res;
//}
//
//function applyTransformationMatToSingleKeypoint(inKeypoint, transformationMat) {
//    return multiply(transformationMat, inKeypoint);
//}
//
//function applyTransformationMatToAllKeypoints(inKeypoints, transformationMat) {
//    var ret = [];
//    for (var i = 0; i < inKeypoints.length; i++)
//    {
//        var transformedKeypoint = applyTransformationMatToSingleKeypoint(inKeypoints[i], transformationMat);
//        ret.push(transformedKeypoint);
//    }
//    return ret;
//}
//
//function convertArrayToKeypointObjects(finalArrayKeypoints) {
//    var ret = [];
//    for (var i = 0; i < finalArrayKeypoints.length; i++)
//    {
//        var arrayKeypoint = finalArrayKeypoints[i];
//        var tempKeypoint = {
//            x: arrayKeypoint[0][0],
//            y: arrayKeypoint[1][0]
//        };
//        ret.push(tempKeypoint)
//    }
//    return ret;
//}
//
//function getNewKeypoints(keypoints, inScale, inRotation, inScaleDirection, inTranspose, centerPointOfRotation, imageSize) {
//
//    //turn the keypoints into arrays with the extra 1 at the end!!!
//    var newKeypoints = convertKeypointsToArrays(keypoints);
//
//    //now calc the transformation mat
//    var transformationMat = getTransformationMatrix(inScale, inRotation, inTranspose, inScaleDirection, centerPointOfRotation, imageSize);
//
//    //then mult each keypoint
//    var finalArrayKeypoints = applyTransformationMatToAllKeypoints(newKeypoints, transformationMat);
//
//    //convert back to keypoint objects
//    var finalKeypoints = convertArrayToKeypointObjects(finalArrayKeypoints);
//
//    return finalKeypoints;
//}
//
//function filterValidPoints(headPoint, tailcombs) {
//    var ret = [];
//
//    for (var i = 0; i < tailcombs.length; i++) {
//        var currPt = tailcombs[i];
//        if (getDistance(currPt, headPoint) < g_maxPntDist && getDistance(currPt, headPoint) > g_minPntDist){
//            ret.push([currPt]);
//        }
//    }
//    return ret;
//}
//
//function filtered_k_combinations(inKeypoints) {
//    var ret = [];
//    for (var i = 0; i < inKeypoints.length - 2; i++) {
//        var keypoint = inKeypoints[i];
//        var tail = inKeypoints.slice(i + 1);
//        var subsetOfValidPoints = filterValidPoints(keypoint, tail);
//        var combs = k_combinations(subsetOfValidPoints, 2);
//        for (var j = 0; j < combs.length; j++) {
//            var currComb = combs[j];
//            var tempTriangle = [keypoint, currComb[0][0], currComb[1][0]];
//            ret.push(tempTriangle);
//        }
//    }
//    return ret;
//}
//
//function k_combinations(set, k) {
//    var i, j, combs, head, tailcombs;
//
//    // There is no way to take e.g. sets of 5 elements from
//    // a set of 4.
//    if (k > set.length || k <= 0) {
//        return [];
//    }
//
//    // K-sized set has only one K-sized subset.
//    if (k == set.length) {
//        return [set];
//    }
//
//    // There is N 1-sized subsets in a N-sized set.
//    if (k == 1) {
//        combs = [];
//        for (i = 0; i < set.length; i++) {
//            combs.push([set[i]]);
//        }
//        return combs;
//    }
//
//    // Assert {1 < k < set.length}
//
//    // Algorithm description:
//    // To get k-combinations of a set, we want to join each element
//    // with all (k-1)-combinations of the other elements. The set of
//    // these k-sized sets would be the desired result. However, as we
//    // represent sets with lists, we need to take duplicates into
//    // account. To avoid producing duplicates and also unnecessary
//    // computing, we use the following approach: each element i
//    // divides the list into three: the preceding elements, the
//    // current element i, and the subsequent elements. For the first
//    // element, the list of preceding elements is empty. For element i,
//    // we compute the (k-1)-computations of the subsequent elements,
//    // join each with the element i, and store the joined to the set of
//    // computed k-combinations. We do not need to take the preceding
//    // elements into account, because they have already been the i:th
//    // element so they are already computed and stored. When the length
//    // of the subsequent list drops below (k-1), we cannot find any
//    // (k-1)-combs, hence the upper limit for the iteration:
//    combs = [];
//    for (i = 0; i < set.length - k + 1; i++) {
//        // head is a list that includes only our current element.
//        head = set.slice(i, i + 1);
//        // We take smaller combinations from the subsequent elements
//        tailcombs = k_combinations(set.slice(i + 1), k - 1);
//        // For each (k-1)-combination we join it with the current
//        // and store it to the set of k-combinations.
//        for (j = 0; j < tailcombs.length; j++) {
//            combs.push(head.concat(tailcombs[j]));
//        }
//    }
//    return combs;
//}
//function getTheTriangles(newKeypoints) {
//    return filtered_k_combinations(newKeypoints);
//}
//
//function drawTriangleWithColour(ctx, tri, colour) {
//    ctx.strokeStyle = 'rgba('+ colour[0] +', '+ colour[1] +' ,'+ colour[2] +', .9)';
//    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
//    ctx.beginPath();
//    ctx.moveTo(tri[0].x, tri[0].y);
//    ctx.lineTo(tri[1].x, tri[1].y);
//    ctx.lineTo(tri[2].x, tri[2].y);
//    ctx.closePath();
//    ctx.stroke();
//}
//
//function drawTriangle(ctx, tri) {
//    drawTriangleWithColour(ctx, tri, [0, 153, 255])
//}
//
//function filterBasedOnVisible(keypoints, boundingBox) {
//    var ret = [];
//    for (var i = 0; i < keypoints.length; i++) {
//        var keypoint = keypoints[i];
//        if( keypoint.x >= boundingBox.x
//            || keypoint.x < 0
//            || keypoint.y >= boundingBox.y
//            || keypoint.y < 0)
//        {
//            //ignore this keypoint
//        } else {
//            ret.push(keypoint)
//        }
//    }
//    return ret;
//}
//
//
//function applyTransformationMatToTriangle(tri, convertToOriginalImageMat) {
//    var ret = [];
//    for (var i = 0; i < tri.length; i++) {
//        var kp = tri[i];
//        kp = convertToNewKeypoint(kp);
//        var newKp = applyTransformationMatToSingleKeypoint(kp, convertToOriginalImageMat);
//        var newKp = {
//            x: newKp[0][0],
//            y: newKp[1][0]
//        };
//        ret.push(newKp);
//    }
//    return ret;
//}
//function isValidTriangle_DrawingTest(newTri) {
//    return getDistance(newTri[0], newTri[1]) < g_maxPntDist
//        && getDistance(newTri[0], newTri[1]) < g_maxPntDist
//        && getDistance(newTri[0], newTri[2]) > g_minPntDist
//        && getDistance(newTri[0], newTri[2]) > g_minPntDist
//        ;
//}
//
//function drawTriangleWithTransformationMatrix(ctx2, tri, convertToOriginalImageMat) {
//
//    var newTri = applyTransformationMatToTriangle(tri, convertToOriginalImageMat);
//    if(isValidTriangle_DrawingTest(newTri)){
//        drawTriangle(ctx2, newTri);
//    } else {
//        if(g_showRedTriangles){
//            drawTriangleWithColour(ctx2, newTri, [255,0,0]);
//        }
//    }
//}
//
//
//function generateRandomKeypoints(imageSize, numberOfKeypoints) {
//
//    var ret = [];
//    for (var i = 0; i < numberOfKeypoints; i++) {
//
//        var x = Math.floor((Math.random() * imageSize.x));
//        var y = Math.floor((Math.random() * imageSize.y));
//        var kp = {
//            x: x,
//            y: y
//        };
//        ret.push(kp)
//    }
//    return ret;
//}
//
//function drawLine(inMouseDownPoint, inMouseCurrentPoint) {
//
//    if (g_currentTranformationOperationState == g_TransformationOperation.ROTATE
//        || g_currentTranformationOperationState == g_TransformationOperation.SCALE) {
//        //continue
//    }else{
//        return;
//    }
//
//    $("#lineSvgTag").css("display", "inline");
//
//    var startx = Math.min(inMouseDownPoint.x, inMouseCurrentPoint.x);
//    var starty = Math.min(inMouseDownPoint.y, inMouseCurrentPoint.y);
//    var endx = Math.max(inMouseDownPoint.x, inMouseCurrentPoint.x);
//    var endy = Math.max(inMouseDownPoint.y, inMouseCurrentPoint.y);
//
//    $( "#lineSvgTag" ).css('left', startx + 'px');
//    $( "#lineSvgTag" ).css('top', starty + 'px');
//
//    var x1 = inMouseDownPoint.x - startx;
//    var y1 = inMouseDownPoint.y - starty;
//    $( "#line" ).attr('x1', x1);
//    $( "#line" ).attr('y1', y1);
//
//    var x2 = inMouseCurrentPoint.x - inMouseDownPoint.x;
//    var y2 = inMouseCurrentPoint.y - inMouseDownPoint.y;
//    $( "#line" ).attr('x2', x2 + x1);
//    $( "#line" ).attr('y2', y2 + y1);
//
//    $( "#lineSvgTag" ).css('width', endx - startx);
//    $( "#lineSvgTag" ).css('height', endy - starty);
//
//}
//
//
//function filterBasedOnClosingPoly(keypoints, coords) {
//    if(coords.length == 0){
//        return keypoints;
//    }
//
//    var ret = [];
//    for (var i = 0; i < keypoints.length; i++) {
//        var keypoint = keypoints[i];
//        if(isPointInPolygon([keypoint.x, keypoint.y], coords)){
//            ret.push(keypoint);
//        }
//    }
//    return ret;
//}
//
//function applyTransformationToEveryPolyPoint(coords, transformationMat) {
//    var ret = [];
//    for (var i = 0; i < coords.length; i++) {
//        var tempKeypoint = applyTransformationMatToSingleKeypoint([[coords[i][0]],[coords[i][1]], [1]], transformationMat);
//        ret.push([tempKeypoint[0][0], tempKeypoint[1][0]]);
//    }
//    return ret;
//}
//
//function getTransformedPolyPoints(coords, inScale, inRotation, inScaleDirection, inTranspose, centerPointOfRotation, imageSize) {
//    if(coords.length == 0){
//        return [];
//    }
//
//    var transformationMat = getTransformationMatrix(inScale, inRotation, inTranspose, inScaleDirection, centerPointOfRotation, imageSize);
//    var tempCoords = applyTransformationToEveryPolyPoint(coords, g_coords_transformation_mat);
//    return applyTransformationToEveryPolyPoint(tempCoords, transformationMat);
//}
//
//function draw() {
//
//    g_transpose = {
//        x: (g_savedTranspose.x + g_currentTranspose.x),
//        y: (g_savedTranspose.y + g_currentTranspose.y)
//    };
//
//    var ctx = document.getElementById('canvas').getContext('2d');
//    var ctx2 = document.getElementById('canvas2').getContext('2d');
//    ctx2.drawImage(sun, 0, 0);
//    ctx.globalCompositeOperation = 'destination-over';
//    ctx.clearRect(0, 0, 512, 512); // clear canvas
//
//    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
//    ctx.strokeStyle = 'rgba(0, 153, 255, 0.4)';
//
//    var time = new Date();
//
//    ctx.save();
//
//    if (isDown) {
//        drawLine(mouseDownPoint, mouseCurrentPoint);
//    }
//
//    ctx.restore();
//
//    //now draw the keypoints
//    var newKeypoints = getNewKeypoints(g_genKeypoints, g_scale, g_rotation, g_scaleDirection, g_transpose, {x: 0, y: 0}, {x: 512, y: 512});
//
//    var transformedPolyPoints = getTransformedPolyPoints(g_coords, g_scale, g_rotation, g_scaleDirection, g_transpose, {x: 0, y: 0}, {x: 512, y: 512});
//    drawClosingPolygon(ctx, transformedPolyPoints);
//
//    if(g_shouldDrawTriangles){
//        var tempFilteredKeypointsStep = filterBasedOnVisible(newKeypoints, {x: 512, y: 512});//input is canvas/imageCutout size
//        var filteredKeypoints = filterBasedOnClosingPoly(tempFilteredKeypointsStep, transformedPolyPoints);//input is canvas/imageCutout size
//
//        var triangles = getTheTriangles(filteredKeypoints);
//        $("#number_of_triangles_output").html("Number of triangles: " + triangles.length);
//        for (var i = 0; i < triangles.length; i++) {
//            var tri = triangles[i];
//            var transMat = getTransformationMatrix(g_scale, g_rotation, g_transpose, g_scaleDirection, {x: 0, y: 0}, {x: 512, y: 512});
//            var convertToOriginalImageMat = math.inv(transMat);
//            drawTriangleWithTransformationMatrix(ctx2, tri, convertToOriginalImageMat);
//            drawTriangle(ctx, tri);
//            //do the translation map
//            //draw the next triangle
//        }
//
//        for (var i = 0; i < filteredKeypoints.length; i++)
//        {
//            var kp = filteredKeypoints[i];
////            ctx.fillStyle = 'rgba(255, 0, 0, 1.0)';
////            ctx.fillRect(kp.x+2,kp.y+2,4,4);
////            ctx.fillStyle = 'rgba(0, 0, 255, 0.5)';
////            ctx.fillRect(kp.x,kp.y,4,4);
//        }
//    }
//
//    ctx.save();
//
//    ctx.translate(g_transpose.x, g_transpose.y);
//    ctx.rotate(g_rotation * Math.PI/180.0 * -1.0);
//    ctx.rotate(g_currentScaleDirection * Math.PI/180.0 * -1.0);
//    ctx.scale(Math.sqrt(g_currentScale), 1.0/Math.sqrt(g_scale));
//    ctx.rotate(g_currentScaleDirection * Math.PI/180.0);
////    ctx.rotate(g_savedScaleDirection * Math.PI/180.0 * -1.0);
////    ctx.scale(Math.sqrt(g_savedScale), 1.0/Math.sqrt(g_scale));
////    ctx.rotate(g_savedScaleDirection * Math.PI/180.0);
////    ctx.translate(sun.width/2, sun.width/2);
//    ctx.drawImage(sun, -sun.width/2, -sun.height/2);
//
//
//    for (var i = 0; i < g_genKeypoints.length; i++)
//    {
//        var kp = g_genKeypoints[i];
////        ctx2.fillStyle = 'rgba(255, 0, 0, 1.0)';
////        ctx2.fillRect(kp.x+2,kp.y+2,4,4);
////        ctx2.fillStyle = 'rgba(0, 0, 255, 0.5)';
////        ctx2.fillRect(kp.x,kp.y,4,4);
//    }
//
//
//    ctx.restore();
//
//    window.requestAnimationFrame(draw);
//}
//
//init();

</script>
</html>
